// @generated by protoc-gen-es v1.2.0 with parameter "target=ts"
// @generated from file transforms.proto (package transforms, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { Expression } from "./expression_pb.js";

/**
 * @generated from enum transforms.SortOrder
 */
export enum SortOrder {
  /**
   * @generated from enum value: Descending = 0;
   */
  Descending = 0,

  /**
   * @generated from enum value: Ascending = 1;
   */
  Ascending = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(SortOrder)
proto3.util.setEnumType(SortOrder, "transforms.SortOrder", [
  { no: 0, name: "Descending" },
  { no: 1, name: "Ascending" },
]);

/**
 * @generated from enum transforms.AggregateOp
 */
export enum AggregateOp {
  /**
   * @generated from enum value: Count = 0;
   */
  Count = 0,

  /**
   * @generated from enum value: Valid = 1;
   */
  Valid = 1,

  /**
   * @generated from enum value: Missing = 2;
   */
  Missing = 2,

  /**
   * @generated from enum value: Distinct = 3;
   */
  Distinct = 3,

  /**
   * @generated from enum value: Sum = 4;
   */
  Sum = 4,

  /**
   * @generated from enum value: Product = 5;
   */
  Product = 5,

  /**
   * @generated from enum value: Mean = 6;
   */
  Mean = 6,

  /**
   * @generated from enum value: Average = 7;
   */
  Average = 7,

  /**
   * @generated from enum value: Variance = 8;
   */
  Variance = 8,

  /**
   * @generated from enum value: Variancep = 9;
   */
  Variancep = 9,

  /**
   * @generated from enum value: Stdev = 10;
   */
  Stdev = 10,

  /**
   * @generated from enum value: Stdevp = 11;
   */
  Stdevp = 11,

  /**
   * @generated from enum value: Stderr = 12;
   */
  Stderr = 12,

  /**
   * @generated from enum value: Median = 13;
   */
  Median = 13,

  /**
   * @generated from enum value: Q1 = 14;
   */
  Q1 = 14,

  /**
   * @generated from enum value: Q3 = 15;
   */
  Q3 = 15,

  /**
   * @generated from enum value: Ci0 = 16;
   */
  Ci0 = 16,

  /**
   * @generated from enum value: Ci1 = 17;
   */
  Ci1 = 17,

  /**
   * @generated from enum value: Min = 18;
   */
  Min = 18,

  /**
   * @generated from enum value: Max = 19;
   */
  Max = 19,

  /**
   * @generated from enum value: Argmin = 20;
   */
  Argmin = 20,

  /**
   * @generated from enum value: Argmax = 21;
   */
  Argmax = 21,

  /**
   * @generated from enum value: Values = 22;
   */
  Values = 22,
}
// Retrieve enum metadata with: proto3.getEnumType(AggregateOp)
proto3.util.setEnumType(AggregateOp, "transforms.AggregateOp", [
  { no: 0, name: "Count" },
  { no: 1, name: "Valid" },
  { no: 2, name: "Missing" },
  { no: 3, name: "Distinct" },
  { no: 4, name: "Sum" },
  { no: 5, name: "Product" },
  { no: 6, name: "Mean" },
  { no: 7, name: "Average" },
  { no: 8, name: "Variance" },
  { no: 9, name: "Variancep" },
  { no: 10, name: "Stdev" },
  { no: 11, name: "Stdevp" },
  { no: 12, name: "Stderr" },
  { no: 13, name: "Median" },
  { no: 14, name: "Q1" },
  { no: 15, name: "Q3" },
  { no: 16, name: "Ci0" },
  { no: 17, name: "Ci1" },
  { no: 18, name: "Min" },
  { no: 19, name: "Max" },
  { no: 20, name: "Argmin" },
  { no: 21, name: "Argmax" },
  { no: 22, name: "Values" },
]);

/**
 * @generated from enum transforms.TimeUnitUnit
 */
export enum TimeUnitUnit {
  /**
   * @generated from enum value: Year = 0;
   */
  Year = 0,

  /**
   * @generated from enum value: Quarter = 1;
   */
  Quarter = 1,

  /**
   * @generated from enum value: Month = 2;
   */
  Month = 2,

  /**
   * @generated from enum value: Date = 3;
   */
  Date = 3,

  /**
   * @generated from enum value: Week = 4;
   */
  Week = 4,

  /**
   * @generated from enum value: Day = 5;
   */
  Day = 5,

  /**
   * @generated from enum value: DayOfYear = 6;
   */
  DayOfYear = 6,

  /**
   * @generated from enum value: Hours = 7;
   */
  Hours = 7,

  /**
   * @generated from enum value: Minutes = 8;
   */
  Minutes = 8,

  /**
   * @generated from enum value: Seconds = 9;
   */
  Seconds = 9,

  /**
   * @generated from enum value: Milliseconds = 10;
   */
  Milliseconds = 10,
}
// Retrieve enum metadata with: proto3.getEnumType(TimeUnitUnit)
proto3.util.setEnumType(TimeUnitUnit, "transforms.TimeUnitUnit", [
  { no: 0, name: "Year" },
  { no: 1, name: "Quarter" },
  { no: 2, name: "Month" },
  { no: 3, name: "Date" },
  { no: 4, name: "Week" },
  { no: 5, name: "Day" },
  { no: 6, name: "DayOfYear" },
  { no: 7, name: "Hours" },
  { no: 8, name: "Minutes" },
  { no: 9, name: "Seconds" },
  { no: 10, name: "Milliseconds" },
]);

/**
 * @generated from enum transforms.TimeUnitTimeZone
 */
export enum TimeUnitTimeZone {
  /**
   * @generated from enum value: Local = 0;
   */
  Local = 0,

  /**
   * @generated from enum value: Utc = 1;
   */
  Utc = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(TimeUnitTimeZone)
proto3.util.setEnumType(TimeUnitTimeZone, "transforms.TimeUnitTimeZone", [
  { no: 0, name: "Local" },
  { no: 1, name: "Utc" },
]);

/**
 * Window
 *
 * @generated from enum transforms.WindowOp
 */
export enum WindowOp {
  /**
   * @generated from enum value: RowNumber = 0;
   */
  RowNumber = 0,

  /**
   * @generated from enum value: Rank = 1;
   */
  Rank = 1,

  /**
   * @generated from enum value: DenseRank = 2;
   */
  DenseRank = 2,

  /**
   * @generated from enum value: PercentileRank = 3;
   */
  PercentileRank = 3,

  /**
   * @generated from enum value: CumeDist = 4;
   */
  CumeDist = 4,

  /**
   * @generated from enum value: NTile = 5;
   */
  NTile = 5,

  /**
   * @generated from enum value: Lag = 6;
   */
  Lag = 6,

  /**
   * @generated from enum value: Lead = 7;
   */
  Lead = 7,

  /**
   * @generated from enum value: FirstValue = 8;
   */
  FirstValue = 8,

  /**
   * @generated from enum value: LastValue = 9;
   */
  LastValue = 9,

  /**
   * @generated from enum value: NthValue = 10;
   */
  NthValue = 10,

  /**
   * @generated from enum value: PrevValue = 11;
   */
  PrevValue = 11,

  /**
   * @generated from enum value: NextValue = 12;
   */
  NextValue = 12,
}
// Retrieve enum metadata with: proto3.getEnumType(WindowOp)
proto3.util.setEnumType(WindowOp, "transforms.WindowOp", [
  { no: 0, name: "RowNumber" },
  { no: 1, name: "Rank" },
  { no: 2, name: "DenseRank" },
  { no: 3, name: "PercentileRank" },
  { no: 4, name: "CumeDist" },
  { no: 5, name: "NTile" },
  { no: 6, name: "Lag" },
  { no: 7, name: "Lead" },
  { no: 8, name: "FirstValue" },
  { no: 9, name: "LastValue" },
  { no: 10, name: "NthValue" },
  { no: 11, name: "PrevValue" },
  { no: 12, name: "NextValue" },
]);

/**
 * @generated from enum transforms.StackOffset
 */
export enum StackOffset {
  /**
   * @generated from enum value: Zero = 0;
   */
  Zero = 0,

  /**
   * @generated from enum value: Center = 1;
   */
  Center = 1,

  /**
   * @generated from enum value: Normalize = 2;
   */
  Normalize = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(StackOffset)
proto3.util.setEnumType(StackOffset, "transforms.StackOffset", [
  { no: 0, name: "Zero" },
  { no: 1, name: "Center" },
  { no: 2, name: "Normalize" },
]);

/**
 * @generated from enum transforms.ImputeMethod
 */
export enum ImputeMethod {
  /**
   * @generated from enum value: ImputeValue = 0;
   */
  ImputeValue = 0,

  /**
   * @generated from enum value: ImputeMean = 1;
   */
  ImputeMean = 1,

  /**
   * @generated from enum value: ImputeMedian = 2;
   */
  ImputeMedian = 2,

  /**
   * @generated from enum value: ImputeMax = 3;
   */
  ImputeMax = 3,

  /**
   * @generated from enum value: ImputeMin = 4;
   */
  ImputeMin = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(ImputeMethod)
proto3.util.setEnumType(ImputeMethod, "transforms.ImputeMethod", [
  { no: 0, name: "ImputeValue" },
  { no: 1, name: "ImputeMean" },
  { no: 2, name: "ImputeMedian" },
  { no: 3, name: "ImputeMax" },
  { no: 4, name: "ImputeMin" },
]);

/**
 * Filter
 *
 * @generated from message transforms.Filter
 */
export class Filter extends Message<Filter> {
  /**
   * @generated from field: expression.Expression expr = 1;
   */
  expr?: Expression;

  constructor(data?: PartialMessage<Filter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "transforms.Filter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "expr", kind: "message", T: Expression },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Filter {
    return new Filter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Filter {
    return new Filter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Filter {
    return new Filter().fromJsonString(jsonString, options);
  }

  static equals(a: Filter | PlainMessage<Filter> | undefined, b: Filter | PlainMessage<Filter> | undefined): boolean {
    return proto3.util.equals(Filter, a, b);
  }
}

/**
 * Formula
 *
 * @generated from message transforms.Formula
 */
export class Formula extends Message<Formula> {
  /**
   * @generated from field: expression.Expression expr = 1;
   */
  expr?: Expression;

  /**
   * @generated from field: string as = 2;
   */
  as = "";

  constructor(data?: PartialMessage<Formula>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "transforms.Formula";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "expr", kind: "message", T: Expression },
    { no: 2, name: "as", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Formula {
    return new Formula().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Formula {
    return new Formula().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Formula {
    return new Formula().fromJsonString(jsonString, options);
  }

  static equals(a: Formula | PlainMessage<Formula> | undefined, b: Formula | PlainMessage<Formula> | undefined): boolean {
    return proto3.util.equals(Formula, a, b);
  }
}

/**
 * Extent
 *
 * @generated from message transforms.Extent
 */
export class Extent extends Message<Extent> {
  /**
   * @generated from field: string field = 1;
   */
  field = "";

  /**
   * @generated from field: optional string signal = 2;
   */
  signal?: string;

  constructor(data?: PartialMessage<Extent>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "transforms.Extent";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "field", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "signal", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Extent {
    return new Extent().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Extent {
    return new Extent().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Extent {
    return new Extent().fromJsonString(jsonString, options);
  }

  static equals(a: Extent | PlainMessage<Extent> | undefined, b: Extent | PlainMessage<Extent> | undefined): boolean {
    return proto3.util.equals(Extent, a, b);
  }
}

/**
 * Collect
 *
 * @generated from message transforms.Collect
 */
export class Collect extends Message<Collect> {
  /**
   * @generated from field: repeated string fields = 1;
   */
  fields: string[] = [];

  /**
   * @generated from field: repeated transforms.SortOrder order = 2;
   */
  order: SortOrder[] = [];

  constructor(data?: PartialMessage<Collect>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "transforms.Collect";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "fields", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "order", kind: "enum", T: proto3.getEnumType(SortOrder), repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Collect {
    return new Collect().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Collect {
    return new Collect().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Collect {
    return new Collect().fromJsonString(jsonString, options);
  }

  static equals(a: Collect | PlainMessage<Collect> | undefined, b: Collect | PlainMessage<Collect> | undefined): boolean {
    return proto3.util.equals(Collect, a, b);
  }
}

/**
 * Bin
 *
 * @generated from message transforms.Bin
 */
export class Bin extends Message<Bin> {
  /**
   * @generated from field: string field = 1;
   */
  field = "";

  /**
   * @generated from field: expression.Expression extent = 2;
   */
  extent?: Expression;

  /**
   * @generated from field: optional string signal = 3;
   */
  signal?: string;

  /**
   * @generated from field: optional string alias_0 = 4;
   */
  alias0?: string;

  /**
   * @generated from field: optional string alias_1 = 5;
   */
  alias1?: string;

  /**
   * A value in the binned domain at which to anchor the bins The bin boundaries will be shifted,
   * if necessary, to ensure that a boundary aligns with the anchor value.
   *
   * @generated from field: optional double anchor = 6;
   */
  anchor?: number;

  /**
   * The maximum number of bins allowed
   *
   * @generated from field: double maxbins = 7;
   */
  maxbins = 0;

  /**
   * The number base to use for automatic bin selection (e.g. base 10)
   *
   * @generated from field: double base = 8;
   */
  base = 0;

  /**
   * An exact step size to use between bins. Overrides other options.
   *
   * @generated from field: optional double step = 9;
   */
  step?: number;

  /**
   * A list of allowable step sizes to choose from
   *
   * @generated from field: repeated double steps = 10;
   */
  steps: number[] = [];

  /**
   * The value span over which to generate bin boundaries. Defaults to the exact extent of the data
   *
   * @generated from field: expression.Expression span = 11;
   */
  span?: Expression;

  /**
   * A minimum distance between adjacent bins
   *
   * @generated from field: double minstep = 12;
   */
  minstep = 0;

  /**
   * Scale factors indicating the allowed subdivisions. The defualt value is vec![5.0, 2.0],
   * which indicates that for base 10 numbers, the method may consider dividing bin sizes by 5 and/or 2.
   *
   * @generated from field: repeated double divide = 13;
   */
  divide: number[] = [];

  /**
   * If true, attempt to make the bin boundaries use human-friendly boundaries
   * (e.g. whole numbers, multiples of 10, etc.)
   *
   * @generated from field: bool nice = 14;
   */
  nice = false;

  constructor(data?: PartialMessage<Bin>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "transforms.Bin";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "field", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "extent", kind: "message", T: Expression },
    { no: 3, name: "signal", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 4, name: "alias_0", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 5, name: "alias_1", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 6, name: "anchor", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, opt: true },
    { no: 7, name: "maxbins", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 8, name: "base", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 9, name: "step", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, opt: true },
    { no: 10, name: "steps", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, repeated: true },
    { no: 11, name: "span", kind: "message", T: Expression },
    { no: 12, name: "minstep", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 13, name: "divide", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, repeated: true },
    { no: 14, name: "nice", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Bin {
    return new Bin().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Bin {
    return new Bin().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Bin {
    return new Bin().fromJsonString(jsonString, options);
  }

  static equals(a: Bin | PlainMessage<Bin> | undefined, b: Bin | PlainMessage<Bin> | undefined): boolean {
    return proto3.util.equals(Bin, a, b);
  }
}

/**
 * Aggregate
 *
 * @generated from message transforms.Aggregate
 */
export class Aggregate extends Message<Aggregate> {
  /**
   * @generated from field: repeated string groupby = 1;
   */
  groupby: string[] = [];

  /**
   * @generated from field: repeated string fields = 2;
   */
  fields: string[] = [];

  /**
   * @generated from field: repeated string aliases = 3;
   */
  aliases: string[] = [];

  /**
   * @generated from field: repeated transforms.AggregateOp ops = 4;
   */
  ops: AggregateOp[] = [];

  constructor(data?: PartialMessage<Aggregate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "transforms.Aggregate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "groupby", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "fields", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "aliases", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "ops", kind: "enum", T: proto3.getEnumType(AggregateOp), repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Aggregate {
    return new Aggregate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Aggregate {
    return new Aggregate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Aggregate {
    return new Aggregate().fromJsonString(jsonString, options);
  }

  static equals(a: Aggregate | PlainMessage<Aggregate> | undefined, b: Aggregate | PlainMessage<Aggregate> | undefined): boolean {
    return proto3.util.equals(Aggregate, a, b);
  }
}

/**
 * JoinAggregate
 *
 * @generated from message transforms.JoinAggregate
 */
export class JoinAggregate extends Message<JoinAggregate> {
  /**
   * @generated from field: repeated string groupby = 1;
   */
  groupby: string[] = [];

  /**
   * @generated from field: repeated string fields = 2;
   */
  fields: string[] = [];

  /**
   * @generated from field: repeated transforms.AggregateOp ops = 3;
   */
  ops: AggregateOp[] = [];

  /**
   * @generated from field: repeated string aliases = 4;
   */
  aliases: string[] = [];

  constructor(data?: PartialMessage<JoinAggregate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "transforms.JoinAggregate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "groupby", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "fields", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "ops", kind: "enum", T: proto3.getEnumType(AggregateOp), repeated: true },
    { no: 4, name: "aliases", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): JoinAggregate {
    return new JoinAggregate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): JoinAggregate {
    return new JoinAggregate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): JoinAggregate {
    return new JoinAggregate().fromJsonString(jsonString, options);
  }

  static equals(a: JoinAggregate | PlainMessage<JoinAggregate> | undefined, b: JoinAggregate | PlainMessage<JoinAggregate> | undefined): boolean {
    return proto3.util.equals(JoinAggregate, a, b);
  }
}

/**
 * TimeUnit
 *
 * @generated from message transforms.TimeUnit
 */
export class TimeUnit extends Message<TimeUnit> {
  /**
   * @generated from field: string field = 1;
   */
  field = "";

  /**
   * @generated from field: repeated transforms.TimeUnitUnit units = 2;
   */
  units: TimeUnitUnit[] = [];

  /**
   * @generated from field: optional string signal = 3;
   */
  signal?: string;

  /**
   * @generated from field: optional string alias_0 = 4;
   */
  alias0?: string;

  /**
   * @generated from field: optional string alias_1 = 5;
   */
  alias1?: string;

  /**
   * @generated from field: optional transforms.TimeUnitTimeZone timezone = 6;
   */
  timezone?: TimeUnitTimeZone;

  constructor(data?: PartialMessage<TimeUnit>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "transforms.TimeUnit";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "field", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "units", kind: "enum", T: proto3.getEnumType(TimeUnitUnit), repeated: true },
    { no: 3, name: "signal", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 4, name: "alias_0", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 5, name: "alias_1", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 6, name: "timezone", kind: "enum", T: proto3.getEnumType(TimeUnitTimeZone), opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TimeUnit {
    return new TimeUnit().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TimeUnit {
    return new TimeUnit().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TimeUnit {
    return new TimeUnit().fromJsonString(jsonString, options);
  }

  static equals(a: TimeUnit | PlainMessage<TimeUnit> | undefined, b: TimeUnit | PlainMessage<TimeUnit> | undefined): boolean {
    return proto3.util.equals(TimeUnit, a, b);
  }
}

/**
 * @generated from message transforms.WindowTransformOp
 */
export class WindowTransformOp extends Message<WindowTransformOp> {
  /**
   * @generated from oneof transforms.WindowTransformOp.op
   */
  op: {
    /**
     * @generated from field: transforms.AggregateOp aggregate_op = 1;
     */
    value: AggregateOp;
    case: "aggregateOp";
  } | {
    /**
     * @generated from field: transforms.WindowOp window_op = 2;
     */
    value: WindowOp;
    case: "windowOp";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<WindowTransformOp>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "transforms.WindowTransformOp";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "aggregate_op", kind: "enum", T: proto3.getEnumType(AggregateOp), oneof: "op" },
    { no: 2, name: "window_op", kind: "enum", T: proto3.getEnumType(WindowOp), oneof: "op" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WindowTransformOp {
    return new WindowTransformOp().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WindowTransformOp {
    return new WindowTransformOp().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WindowTransformOp {
    return new WindowTransformOp().fromJsonString(jsonString, options);
  }

  static equals(a: WindowTransformOp | PlainMessage<WindowTransformOp> | undefined, b: WindowTransformOp | PlainMessage<WindowTransformOp> | undefined): boolean {
    return proto3.util.equals(WindowTransformOp, a, b);
  }
}

/**
 * @generated from message transforms.Window
 */
export class Window extends Message<Window> {
  /**
   * @generated from field: repeated transforms.SortOrder sort = 1;
   */
  sort: SortOrder[] = [];

  /**
   * @generated from field: repeated string sort_fields = 2;
   */
  sortFields: string[] = [];

  /**
   * @generated from field: repeated string groupby = 3;
   */
  groupby: string[] = [];

  /**
   * @generated from field: repeated transforms.WindowTransformOp ops = 4;
   */
  ops: WindowTransformOp[] = [];

  /**
   * @generated from field: repeated string fields = 5;
   */
  fields: string[] = [];

  /**
   * @generated from field: repeated double params = 6;
   */
  params: number[] = [];

  /**
   * @generated from field: repeated string aliases = 7;
   */
  aliases: string[] = [];

  /**
   * @generated from field: optional transforms.WindowFrame frame = 8;
   */
  frame?: WindowFrame;

  /**
   * @generated from field: optional bool ignore_peers = 9;
   */
  ignorePeers?: boolean;

  constructor(data?: PartialMessage<Window>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "transforms.Window";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "sort", kind: "enum", T: proto3.getEnumType(SortOrder), repeated: true },
    { no: 2, name: "sort_fields", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "groupby", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "ops", kind: "message", T: WindowTransformOp, repeated: true },
    { no: 5, name: "fields", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 6, name: "params", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, repeated: true },
    { no: 7, name: "aliases", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 8, name: "frame", kind: "message", T: WindowFrame, opt: true },
    { no: 9, name: "ignore_peers", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Window {
    return new Window().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Window {
    return new Window().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Window {
    return new Window().fromJsonString(jsonString, options);
  }

  static equals(a: Window | PlainMessage<Window> | undefined, b: Window | PlainMessage<Window> | undefined): boolean {
    return proto3.util.equals(Window, a, b);
  }
}

/**
 * @generated from message transforms.WindowFrame
 */
export class WindowFrame extends Message<WindowFrame> {
  /**
   * @generated from field: optional int64 start = 1;
   */
  start?: bigint;

  /**
   * @generated from field: optional int64 end = 2;
   */
  end?: bigint;

  constructor(data?: PartialMessage<WindowFrame>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "transforms.WindowFrame";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "start", kind: "scalar", T: 3 /* ScalarType.INT64 */, opt: true },
    { no: 2, name: "end", kind: "scalar", T: 3 /* ScalarType.INT64 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WindowFrame {
    return new WindowFrame().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WindowFrame {
    return new WindowFrame().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WindowFrame {
    return new WindowFrame().fromJsonString(jsonString, options);
  }

  static equals(a: WindowFrame | PlainMessage<WindowFrame> | undefined, b: WindowFrame | PlainMessage<WindowFrame> | undefined): boolean {
    return proto3.util.equals(WindowFrame, a, b);
  }
}

/**
 * Project
 *
 * @generated from message transforms.Project
 */
export class Project extends Message<Project> {
  /**
   * @generated from field: repeated string fields = 1;
   */
  fields: string[] = [];

  constructor(data?: PartialMessage<Project>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "transforms.Project";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "fields", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Project {
    return new Project().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Project {
    return new Project().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Project {
    return new Project().fromJsonString(jsonString, options);
  }

  static equals(a: Project | PlainMessage<Project> | undefined, b: Project | PlainMessage<Project> | undefined): boolean {
    return proto3.util.equals(Project, a, b);
  }
}

/**
 * Stack
 *
 * @generated from message transforms.Stack
 */
export class Stack extends Message<Stack> {
  /**
   * @generated from field: string field = 1;
   */
  field = "";

  /**
   * @generated from field: transforms.StackOffset offset = 2;
   */
  offset = StackOffset.Zero;

  /**
   * @generated from field: repeated transforms.SortOrder sort = 3;
   */
  sort: SortOrder[] = [];

  /**
   * @generated from field: repeated string sort_fields = 4;
   */
  sortFields: string[] = [];

  /**
   * @generated from field: repeated string groupby = 5;
   */
  groupby: string[] = [];

  /**
   * @generated from field: optional string alias_0 = 6;
   */
  alias0?: string;

  /**
   * @generated from field: optional string alias_1 = 7;
   */
  alias1?: string;

  constructor(data?: PartialMessage<Stack>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "transforms.Stack";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "field", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "offset", kind: "enum", T: proto3.getEnumType(StackOffset) },
    { no: 3, name: "sort", kind: "enum", T: proto3.getEnumType(SortOrder), repeated: true },
    { no: 4, name: "sort_fields", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 5, name: "groupby", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 6, name: "alias_0", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 7, name: "alias_1", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Stack {
    return new Stack().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Stack {
    return new Stack().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Stack {
    return new Stack().fromJsonString(jsonString, options);
  }

  static equals(a: Stack | PlainMessage<Stack> | undefined, b: Stack | PlainMessage<Stack> | undefined): boolean {
    return proto3.util.equals(Stack, a, b);
  }
}

/**
 * Impute
 *
 * @generated from message transforms.Impute
 */
export class Impute extends Message<Impute> {
  /**
   * @generated from field: string field = 1;
   */
  field = "";

  /**
   * @generated from field: string key = 2;
   */
  key = "";

  /**
   * @generated from field: transforms.ImputeMethod method = 3;
   */
  method = ImputeMethod.ImputeValue;

  /**
   * @generated from field: repeated string groupby = 4;
   */
  groupby: string[] = [];

  /**
   * @generated from field: optional string value_json = 5;
   */
  valueJson?: string;

  constructor(data?: PartialMessage<Impute>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "transforms.Impute";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "field", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "method", kind: "enum", T: proto3.getEnumType(ImputeMethod) },
    { no: 4, name: "groupby", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 5, name: "value_json", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Impute {
    return new Impute().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Impute {
    return new Impute().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Impute {
    return new Impute().fromJsonString(jsonString, options);
  }

  static equals(a: Impute | PlainMessage<Impute> | undefined, b: Impute | PlainMessage<Impute> | undefined): boolean {
    return proto3.util.equals(Impute, a, b);
  }
}

/**
 * Pivot
 *
 * @generated from message transforms.Pivot
 */
export class Pivot extends Message<Pivot> {
  /**
   * @generated from field: string field = 1;
   */
  field = "";

  /**
   * @generated from field: string value = 2;
   */
  value = "";

  /**
   * @generated from field: repeated string groupby = 3;
   */
  groupby: string[] = [];

  /**
   * @generated from field: optional int32 limit = 4;
   */
  limit?: number;

  /**
   * @generated from field: optional transforms.AggregateOp op = 5;
   */
  op?: AggregateOp;

  constructor(data?: PartialMessage<Pivot>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "transforms.Pivot";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "field", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "value", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "groupby", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "limit", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 5, name: "op", kind: "enum", T: proto3.getEnumType(AggregateOp), opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Pivot {
    return new Pivot().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Pivot {
    return new Pivot().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Pivot {
    return new Pivot().fromJsonString(jsonString, options);
  }

  static equals(a: Pivot | PlainMessage<Pivot> | undefined, b: Pivot | PlainMessage<Pivot> | undefined): boolean {
    return proto3.util.equals(Pivot, a, b);
  }
}

/**
 * Identifier
 *
 * @generated from message transforms.Identifier
 */
export class Identifier extends Message<Identifier> {
  /**
   * @generated from field: string as = 1;
   */
  as = "";

  constructor(data?: PartialMessage<Identifier>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "transforms.Identifier";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "as", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Identifier {
    return new Identifier().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Identifier {
    return new Identifier().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Identifier {
    return new Identifier().fromJsonString(jsonString, options);
  }

  static equals(a: Identifier | PlainMessage<Identifier> | undefined, b: Identifier | PlainMessage<Identifier> | undefined): boolean {
    return proto3.util.equals(Identifier, a, b);
  }
}

/**
 * Fold
 *
 * @generated from message transforms.Fold
 */
export class Fold extends Message<Fold> {
  /**
   * @generated from field: repeated string fields = 1;
   */
  fields: string[] = [];

  /**
   * @generated from field: repeated string as = 2;
   */
  as: string[] = [];

  constructor(data?: PartialMessage<Fold>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "transforms.Fold";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "fields", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "as", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Fold {
    return new Fold().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Fold {
    return new Fold().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Fold {
    return new Fold().fromJsonString(jsonString, options);
  }

  static equals(a: Fold | PlainMessage<Fold> | undefined, b: Fold | PlainMessage<Fold> | undefined): boolean {
    return proto3.util.equals(Fold, a, b);
  }
}

/**
 * Sequence
 *
 * @generated from message transforms.Sequence
 */
export class Sequence extends Message<Sequence> {
  /**
   * @generated from field: expression.Expression start = 1;
   */
  start?: Expression;

  /**
   * @generated from field: expression.Expression stop = 2;
   */
  stop?: Expression;

  /**
   * @generated from field: optional expression.Expression step = 3;
   */
  step?: Expression;

  /**
   * @generated from field: optional string as = 4;
   */
  as?: string;

  constructor(data?: PartialMessage<Sequence>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "transforms.Sequence";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "start", kind: "message", T: Expression },
    { no: 2, name: "stop", kind: "message", T: Expression },
    { no: 3, name: "step", kind: "message", T: Expression, opt: true },
    { no: 4, name: "as", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Sequence {
    return new Sequence().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Sequence {
    return new Sequence().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Sequence {
    return new Sequence().fromJsonString(jsonString, options);
  }

  static equals(a: Sequence | PlainMessage<Sequence> | undefined, b: Sequence | PlainMessage<Sequence> | undefined): boolean {
    return proto3.util.equals(Sequence, a, b);
  }
}

/**
 * Top-level transform
 *
 * @generated from message transforms.Transform
 */
export class Transform extends Message<Transform> {
  /**
   * @generated from oneof transforms.Transform.transform_kind
   */
  transformKind: {
    /**
     * @generated from field: transforms.Filter filter = 1;
     */
    value: Filter;
    case: "filter";
  } | {
    /**
     * @generated from field: transforms.Extent extent = 2;
     */
    value: Extent;
    case: "extent";
  } | {
    /**
     * @generated from field: transforms.Formula formula = 3;
     */
    value: Formula;
    case: "formula";
  } | {
    /**
     * @generated from field: transforms.Bin bin = 4;
     */
    value: Bin;
    case: "bin";
  } | {
    /**
     * @generated from field: transforms.Aggregate aggregate = 5;
     */
    value: Aggregate;
    case: "aggregate";
  } | {
    /**
     * @generated from field: transforms.Collect collect = 6;
     */
    value: Collect;
    case: "collect";
  } | {
    /**
     * @generated from field: transforms.TimeUnit timeunit = 7;
     */
    value: TimeUnit;
    case: "timeunit";
  } | {
    /**
     * @generated from field: transforms.JoinAggregate joinaggregate = 8;
     */
    value: JoinAggregate;
    case: "joinaggregate";
  } | {
    /**
     * @generated from field: transforms.Window window = 9;
     */
    value: Window;
    case: "window";
  } | {
    /**
     * @generated from field: transforms.Project project = 10;
     */
    value: Project;
    case: "project";
  } | {
    /**
     * @generated from field: transforms.Stack stack = 11;
     */
    value: Stack;
    case: "stack";
  } | {
    /**
     * @generated from field: transforms.Impute impute = 12;
     */
    value: Impute;
    case: "impute";
  } | {
    /**
     * @generated from field: transforms.Pivot pivot = 13;
     */
    value: Pivot;
    case: "pivot";
  } | {
    /**
     * @generated from field: transforms.Identifier identifier = 14;
     */
    value: Identifier;
    case: "identifier";
  } | {
    /**
     * @generated from field: transforms.Fold fold = 15;
     */
    value: Fold;
    case: "fold";
  } | {
    /**
     * @generated from field: transforms.Sequence sequence = 16;
     */
    value: Sequence;
    case: "sequence";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Transform>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "transforms.Transform";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "filter", kind: "message", T: Filter, oneof: "transform_kind" },
    { no: 2, name: "extent", kind: "message", T: Extent, oneof: "transform_kind" },
    { no: 3, name: "formula", kind: "message", T: Formula, oneof: "transform_kind" },
    { no: 4, name: "bin", kind: "message", T: Bin, oneof: "transform_kind" },
    { no: 5, name: "aggregate", kind: "message", T: Aggregate, oneof: "transform_kind" },
    { no: 6, name: "collect", kind: "message", T: Collect, oneof: "transform_kind" },
    { no: 7, name: "timeunit", kind: "message", T: TimeUnit, oneof: "transform_kind" },
    { no: 8, name: "joinaggregate", kind: "message", T: JoinAggregate, oneof: "transform_kind" },
    { no: 9, name: "window", kind: "message", T: Window, oneof: "transform_kind" },
    { no: 10, name: "project", kind: "message", T: Project, oneof: "transform_kind" },
    { no: 11, name: "stack", kind: "message", T: Stack, oneof: "transform_kind" },
    { no: 12, name: "impute", kind: "message", T: Impute, oneof: "transform_kind" },
    { no: 13, name: "pivot", kind: "message", T: Pivot, oneof: "transform_kind" },
    { no: 14, name: "identifier", kind: "message", T: Identifier, oneof: "transform_kind" },
    { no: 15, name: "fold", kind: "message", T: Fold, oneof: "transform_kind" },
    { no: 16, name: "sequence", kind: "message", T: Sequence, oneof: "transform_kind" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Transform {
    return new Transform().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Transform {
    return new Transform().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Transform {
    return new Transform().fromJsonString(jsonString, options);
  }

  static equals(a: Transform | PlainMessage<Transform> | undefined, b: Transform | PlainMessage<Transform> | undefined): boolean {
    return proto3.util.equals(Transform, a, b);
  }
}

/**
 * @generated from message transforms.TransformPipeline
 */
export class TransformPipeline extends Message<TransformPipeline> {
  /**
   * @generated from field: repeated transforms.Transform transforms = 1;
   */
  transforms: Transform[] = [];

  constructor(data?: PartialMessage<TransformPipeline>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "transforms.TransformPipeline";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "transforms", kind: "message", T: Transform, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TransformPipeline {
    return new TransformPipeline().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TransformPipeline {
    return new TransformPipeline().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TransformPipeline {
    return new TransformPipeline().fromJsonString(jsonString, options);
  }

  static equals(a: TransformPipeline | PlainMessage<TransformPipeline> | undefined, b: TransformPipeline | PlainMessage<TransformPipeline> | undefined): boolean {
    return proto3.util.equals(TransformPipeline, a, b);
  }
}

