// @generated by protoc-gen-es v1.2.0 with parameter "target=ts"
// @generated from file expression.proto (package expression, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";

/**
 * @generated from enum expression.UnaryOperator
 */
export enum UnaryOperator {
  /**
   * @generated from enum value: Pos = 0;
   */
  Pos = 0,

  /**
   * @generated from enum value: Neg = 1;
   */
  Neg = 1,

  /**
   * @generated from enum value: Not = 2;
   */
  Not = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(UnaryOperator)
proto3.util.setEnumType(UnaryOperator, "expression.UnaryOperator", [
  { no: 0, name: "Pos" },
  { no: 1, name: "Neg" },
  { no: 2, name: "Not" },
]);

/**
 * @generated from enum expression.LogicalOperator
 */
export enum LogicalOperator {
  /**
   * @generated from enum value: Or = 0;
   */
  Or = 0,

  /**
   * @generated from enum value: And = 1;
   */
  And = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(LogicalOperator)
proto3.util.setEnumType(LogicalOperator, "expression.LogicalOperator", [
  { no: 0, name: "Or" },
  { no: 1, name: "And" },
]);

/**
 * @generated from enum expression.BinaryOperator
 */
export enum BinaryOperator {
  /**
   * @generated from enum value: Equals = 0;
   */
  Equals = 0,

  /**
   * @generated from enum value: NotEquals = 1;
   */
  NotEquals = 1,

  /**
   * @generated from enum value: StrictEquals = 2;
   */
  StrictEquals = 2,

  /**
   * @generated from enum value: NotStrictEquals = 3;
   */
  NotStrictEquals = 3,

  /**
   * @generated from enum value: LessThan = 4;
   */
  LessThan = 4,

  /**
   * @generated from enum value: LessThanEqual = 5;
   */
  LessThanEqual = 5,

  /**
   * @generated from enum value: GreaterThan = 6;
   */
  GreaterThan = 6,

  /**
   * @generated from enum value: GreaterThanEqual = 7;
   */
  GreaterThanEqual = 7,

  /**
   * @generated from enum value: Plus = 8;
   */
  Plus = 8,

  /**
   * @generated from enum value: Minus = 9;
   */
  Minus = 9,

  /**
   * @generated from enum value: Mult = 10;
   */
  Mult = 10,

  /**
   * @generated from enum value: Div = 11;
   */
  Div = 11,

  /**
   * @generated from enum value: Mod = 12;
   */
  Mod = 12,
}
// Retrieve enum metadata with: proto3.getEnumType(BinaryOperator)
proto3.util.setEnumType(BinaryOperator, "expression.BinaryOperator", [
  { no: 0, name: "Equals" },
  { no: 1, name: "NotEquals" },
  { no: 2, name: "StrictEquals" },
  { no: 3, name: "NotStrictEquals" },
  { no: 4, name: "LessThan" },
  { no: 5, name: "LessThanEqual" },
  { no: 6, name: "GreaterThan" },
  { no: 7, name: "GreaterThanEqual" },
  { no: 8, name: "Plus" },
  { no: 9, name: "Minus" },
  { no: 10, name: "Mult" },
  { no: 11, name: "Div" },
  { no: 12, name: "Mod" },
]);

/**
 * ESTree-style AST nodes
 *
 * @generated from message expression.Span
 */
export class Span extends Message<Span> {
  /**
   * @generated from field: int32 start = 1;
   */
  start = 0;

  /**
   * @generated from field: int32 end = 2;
   */
  end = 0;

  constructor(data?: PartialMessage<Span>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "expression.Span";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "start", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "end", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Span {
    return new Span().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Span {
    return new Span().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Span {
    return new Span().fromJsonString(jsonString, options);
  }

  static equals(a: Span | PlainMessage<Span> | undefined, b: Span | PlainMessage<Span> | undefined): boolean {
    return proto3.util.equals(Span, a, b);
  }
}

/**
 * @generated from message expression.Literal
 */
export class Literal extends Message<Literal> {
  /**
   * @generated from field: string raw = 1;
   */
  raw = "";

  /**
   * @generated from oneof expression.Literal.value
   */
  value: {
    /**
     * @generated from field: string string = 2;
     */
    value: string;
    case: "string";
  } | {
    /**
     * @generated from field: bool boolean = 3;
     */
    value: boolean;
    case: "boolean";
  } | {
    /**
     * @generated from field: double number = 4;
     */
    value: number;
    case: "number";
  } | {
    /**
     * @generated from field: bool null = 5;
     */
    value: boolean;
    case: "null";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Literal>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "expression.Literal";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "raw", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "string", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "value" },
    { no: 3, name: "boolean", kind: "scalar", T: 8 /* ScalarType.BOOL */, oneof: "value" },
    { no: 4, name: "number", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, oneof: "value" },
    { no: 5, name: "null", kind: "scalar", T: 8 /* ScalarType.BOOL */, oneof: "value" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Literal {
    return new Literal().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Literal {
    return new Literal().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Literal {
    return new Literal().fromJsonString(jsonString, options);
  }

  static equals(a: Literal | PlainMessage<Literal> | undefined, b: Literal | PlainMessage<Literal> | undefined): boolean {
    return proto3.util.equals(Literal, a, b);
  }
}

/**
 * @generated from message expression.IdentifierABC
 */
export class IdentifierABC extends Message<IdentifierABC> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  constructor(data?: PartialMessage<IdentifierABC>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "expression.IdentifierABC";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IdentifierABC {
    return new IdentifierABC().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IdentifierABC {
    return new IdentifierABC().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IdentifierABC {
    return new IdentifierABC().fromJsonString(jsonString, options);
  }

  static equals(a: IdentifierABC | PlainMessage<IdentifierABC> | undefined, b: IdentifierABC | PlainMessage<IdentifierABC> | undefined): boolean {
    return proto3.util.equals(IdentifierABC, a, b);
  }
}

/**
 * @generated from message expression.Identifier
 */
export class Identifier extends Message<Identifier> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  constructor(data?: PartialMessage<Identifier>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "expression.Identifier";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Identifier {
    return new Identifier().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Identifier {
    return new Identifier().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Identifier {
    return new Identifier().fromJsonString(jsonString, options);
  }

  static equals(a: Identifier | PlainMessage<Identifier> | undefined, b: Identifier | PlainMessage<Identifier> | undefined): boolean {
    return proto3.util.equals(Identifier, a, b);
  }
}

/**
 * @generated from message expression.UnaryExpression
 */
export class UnaryExpression extends Message<UnaryExpression> {
  /**
   * @generated from field: expression.UnaryOperator operator = 1;
   */
  operator = UnaryOperator.Pos;

  /**
   * @generated from field: bool prefix = 2;
   */
  prefix = false;

  /**
   * @generated from field: expression.Expression argument = 3;
   */
  argument?: Expression;

  constructor(data?: PartialMessage<UnaryExpression>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "expression.UnaryExpression";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "operator", kind: "enum", T: proto3.getEnumType(UnaryOperator) },
    { no: 2, name: "prefix", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "argument", kind: "message", T: Expression },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UnaryExpression {
    return new UnaryExpression().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UnaryExpression {
    return new UnaryExpression().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UnaryExpression {
    return new UnaryExpression().fromJsonString(jsonString, options);
  }

  static equals(a: UnaryExpression | PlainMessage<UnaryExpression> | undefined, b: UnaryExpression | PlainMessage<UnaryExpression> | undefined): boolean {
    return proto3.util.equals(UnaryExpression, a, b);
  }
}

/**
 * @generated from message expression.LogicalExpression
 */
export class LogicalExpression extends Message<LogicalExpression> {
  /**
   * @generated from field: expression.Expression left = 1;
   */
  left?: Expression;

  /**
   * @generated from field: expression.LogicalOperator operator = 2;
   */
  operator = LogicalOperator.Or;

  /**
   * @generated from field: expression.Expression right = 3;
   */
  right?: Expression;

  constructor(data?: PartialMessage<LogicalExpression>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "expression.LogicalExpression";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "left", kind: "message", T: Expression },
    { no: 2, name: "operator", kind: "enum", T: proto3.getEnumType(LogicalOperator) },
    { no: 3, name: "right", kind: "message", T: Expression },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LogicalExpression {
    return new LogicalExpression().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LogicalExpression {
    return new LogicalExpression().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LogicalExpression {
    return new LogicalExpression().fromJsonString(jsonString, options);
  }

  static equals(a: LogicalExpression | PlainMessage<LogicalExpression> | undefined, b: LogicalExpression | PlainMessage<LogicalExpression> | undefined): boolean {
    return proto3.util.equals(LogicalExpression, a, b);
  }
}

/**
 * @generated from message expression.BinaryExpression
 */
export class BinaryExpression extends Message<BinaryExpression> {
  /**
   * @generated from field: expression.Expression left = 1;
   */
  left?: Expression;

  /**
   * @generated from field: expression.BinaryOperator operator = 2;
   */
  operator = BinaryOperator.Equals;

  /**
   * @generated from field: expression.Expression right = 3;
   */
  right?: Expression;

  constructor(data?: PartialMessage<BinaryExpression>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "expression.BinaryExpression";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "left", kind: "message", T: Expression },
    { no: 2, name: "operator", kind: "enum", T: proto3.getEnumType(BinaryOperator) },
    { no: 3, name: "right", kind: "message", T: Expression },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BinaryExpression {
    return new BinaryExpression().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BinaryExpression {
    return new BinaryExpression().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BinaryExpression {
    return new BinaryExpression().fromJsonString(jsonString, options);
  }

  static equals(a: BinaryExpression | PlainMessage<BinaryExpression> | undefined, b: BinaryExpression | PlainMessage<BinaryExpression> | undefined): boolean {
    return proto3.util.equals(BinaryExpression, a, b);
  }
}

/**
 * @generated from message expression.ConditionalExpression
 */
export class ConditionalExpression extends Message<ConditionalExpression> {
  /**
   * @generated from field: expression.Expression test = 1;
   */
  test?: Expression;

  /**
   * @generated from field: expression.Expression consequent = 2;
   */
  consequent?: Expression;

  /**
   * @generated from field: expression.Expression alternate = 3;
   */
  alternate?: Expression;

  constructor(data?: PartialMessage<ConditionalExpression>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "expression.ConditionalExpression";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "test", kind: "message", T: Expression },
    { no: 2, name: "consequent", kind: "message", T: Expression },
    { no: 3, name: "alternate", kind: "message", T: Expression },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ConditionalExpression {
    return new ConditionalExpression().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ConditionalExpression {
    return new ConditionalExpression().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ConditionalExpression {
    return new ConditionalExpression().fromJsonString(jsonString, options);
  }

  static equals(a: ConditionalExpression | PlainMessage<ConditionalExpression> | undefined, b: ConditionalExpression | PlainMessage<ConditionalExpression> | undefined): boolean {
    return proto3.util.equals(ConditionalExpression, a, b);
  }
}

/**
 * @generated from message expression.MemberExpression
 */
export class MemberExpression extends Message<MemberExpression> {
  /**
   * @generated from field: expression.Expression object = 1;
   */
  object?: Expression;

  /**
   * @generated from field: expression.Expression property = 2;
   */
  property?: Expression;

  /**
   * @generated from field: bool computed = 3;
   */
  computed = false;

  constructor(data?: PartialMessage<MemberExpression>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "expression.MemberExpression";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "object", kind: "message", T: Expression },
    { no: 2, name: "property", kind: "message", T: Expression },
    { no: 3, name: "computed", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MemberExpression {
    return new MemberExpression().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MemberExpression {
    return new MemberExpression().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MemberExpression {
    return new MemberExpression().fromJsonString(jsonString, options);
  }

  static equals(a: MemberExpression | PlainMessage<MemberExpression> | undefined, b: MemberExpression | PlainMessage<MemberExpression> | undefined): boolean {
    return proto3.util.equals(MemberExpression, a, b);
  }
}

/**
 * @generated from message expression.ArrayExpression
 */
export class ArrayExpression extends Message<ArrayExpression> {
  /**
   * @generated from field: repeated expression.Expression elements = 1;
   */
  elements: Expression[] = [];

  constructor(data?: PartialMessage<ArrayExpression>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "expression.ArrayExpression";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "elements", kind: "message", T: Expression, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ArrayExpression {
    return new ArrayExpression().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ArrayExpression {
    return new ArrayExpression().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ArrayExpression {
    return new ArrayExpression().fromJsonString(jsonString, options);
  }

  static equals(a: ArrayExpression | PlainMessage<ArrayExpression> | undefined, b: ArrayExpression | PlainMessage<ArrayExpression> | undefined): boolean {
    return proto3.util.equals(ArrayExpression, a, b);
  }
}

/**
 * @generated from message expression.CallExpression
 */
export class CallExpression extends Message<CallExpression> {
  /**
   * @generated from field: string callee = 1;
   */
  callee = "";

  /**
   * @generated from field: repeated expression.Expression arguments = 2;
   */
  arguments: Expression[] = [];

  constructor(data?: PartialMessage<CallExpression>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "expression.CallExpression";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "callee", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "arguments", kind: "message", T: Expression, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CallExpression {
    return new CallExpression().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CallExpression {
    return new CallExpression().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CallExpression {
    return new CallExpression().fromJsonString(jsonString, options);
  }

  static equals(a: CallExpression | PlainMessage<CallExpression> | undefined, b: CallExpression | PlainMessage<CallExpression> | undefined): boolean {
    return proto3.util.equals(CallExpression, a, b);
  }
}

/**
 * @generated from message expression.Property
 */
export class Property extends Message<Property> {
  /**
   * @generated from oneof expression.Property.key
   */
  key: {
    /**
     * @generated from field: expression.Literal literal = 1;
     */
    value: Literal;
    case: "literal";
  } | {
    /**
     * @generated from field: expression.Identifier identifier = 2;
     */
    value: Identifier;
    case: "identifier";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * @generated from field: expression.Expression value = 3;
   */
  value?: Expression;

  /**
   * @generated from field: string kind = 4;
   */
  kind = "";

  constructor(data?: PartialMessage<Property>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "expression.Property";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "literal", kind: "message", T: Literal, oneof: "key" },
    { no: 2, name: "identifier", kind: "message", T: Identifier, oneof: "key" },
    { no: 3, name: "value", kind: "message", T: Expression },
    { no: 4, name: "kind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Property {
    return new Property().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Property {
    return new Property().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Property {
    return new Property().fromJsonString(jsonString, options);
  }

  static equals(a: Property | PlainMessage<Property> | undefined, b: Property | PlainMessage<Property> | undefined): boolean {
    return proto3.util.equals(Property, a, b);
  }
}

/**
 * @generated from message expression.ObjectExpression
 */
export class ObjectExpression extends Message<ObjectExpression> {
  /**
   * @generated from field: repeated expression.Property properties = 1;
   */
  properties: Property[] = [];

  constructor(data?: PartialMessage<ObjectExpression>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "expression.ObjectExpression";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "properties", kind: "message", T: Property, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ObjectExpression {
    return new ObjectExpression().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ObjectExpression {
    return new ObjectExpression().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ObjectExpression {
    return new ObjectExpression().fromJsonString(jsonString, options);
  }

  static equals(a: ObjectExpression | PlainMessage<ObjectExpression> | undefined, b: ObjectExpression | PlainMessage<ObjectExpression> | undefined): boolean {
    return proto3.util.equals(ObjectExpression, a, b);
  }
}

/**
 * Top-level expression
 *
 * @generated from message expression.Expression
 */
export class Expression extends Message<Expression> {
  /**
   * @generated from oneof expression.Expression.expr
   */
  expr: {
    /**
     * @generated from field: expression.Identifier identifier = 1;
     */
    value: Identifier;
    case: "identifier";
  } | {
    /**
     * @generated from field: expression.Literal literal = 2;
     */
    value: Literal;
    case: "literal";
  } | {
    /**
     * @generated from field: expression.BinaryExpression binary = 3;
     */
    value: BinaryExpression;
    case: "binary";
  } | {
    /**
     * @generated from field: expression.LogicalExpression logical = 4;
     */
    value: LogicalExpression;
    case: "logical";
  } | {
    /**
     * @generated from field: expression.UnaryExpression unary = 5;
     */
    value: UnaryExpression;
    case: "unary";
  } | {
    /**
     * @generated from field: expression.ConditionalExpression conditional = 6;
     */
    value: ConditionalExpression;
    case: "conditional";
  } | {
    /**
     * @generated from field: expression.CallExpression call = 7;
     */
    value: CallExpression;
    case: "call";
  } | {
    /**
     * @generated from field: expression.ArrayExpression array = 8;
     */
    value: ArrayExpression;
    case: "array";
  } | {
    /**
     * @generated from field: expression.ObjectExpression object = 9;
     */
    value: ObjectExpression;
    case: "object";
  } | {
    /**
     * @generated from field: expression.MemberExpression member = 10;
     */
    value: MemberExpression;
    case: "member";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * @generated from field: expression.Span span = 11;
   */
  span?: Span;

  constructor(data?: PartialMessage<Expression>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "expression.Expression";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "identifier", kind: "message", T: Identifier, oneof: "expr" },
    { no: 2, name: "literal", kind: "message", T: Literal, oneof: "expr" },
    { no: 3, name: "binary", kind: "message", T: BinaryExpression, oneof: "expr" },
    { no: 4, name: "logical", kind: "message", T: LogicalExpression, oneof: "expr" },
    { no: 5, name: "unary", kind: "message", T: UnaryExpression, oneof: "expr" },
    { no: 6, name: "conditional", kind: "message", T: ConditionalExpression, oneof: "expr" },
    { no: 7, name: "call", kind: "message", T: CallExpression, oneof: "expr" },
    { no: 8, name: "array", kind: "message", T: ArrayExpression, oneof: "expr" },
    { no: 9, name: "object", kind: "message", T: ObjectExpression, oneof: "expr" },
    { no: 10, name: "member", kind: "message", T: MemberExpression, oneof: "expr" },
    { no: 11, name: "span", kind: "message", T: Span },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Expression {
    return new Expression().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Expression {
    return new Expression().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Expression {
    return new Expression().fromJsonString(jsonString, options);
  }

  static equals(a: Expression | PlainMessage<Expression> | undefined, b: Expression | PlainMessage<Expression> | undefined): boolean {
    return proto3.util.equals(Expression, a, b);
  }
}

