// @generated by protoc-gen-es v1.2.0 with parameter "target=ts"
// @generated from file tasks.proto (package tasks, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";
import { Expression } from "./expression_pb.js";
import { TransformPipeline } from "./transforms_pb.js";

/**
 * ## Variable
 *
 * @generated from enum tasks.VariableNamespace
 */
export enum VariableNamespace {
  /**
   * @generated from enum value: Signal = 0;
   */
  Signal = 0,

  /**
   * @generated from enum value: Data = 1;
   */
  Data = 1,

  /**
   * @generated from enum value: Scale = 2;
   */
  Scale = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(VariableNamespace)
proto3.util.setEnumType(VariableNamespace, "tasks.VariableNamespace", [
  { no: 0, name: "Signal" },
  { no: 1, name: "Data" },
  { no: 2, name: "Scale" },
]);

/**
 * ## Task Value
 *
 * @generated from message tasks.TaskValue
 */
export class TaskValue extends Message<TaskValue> {
  /**
   * @generated from oneof tasks.TaskValue.data
   */
  data: {
    /**
     *
     * Representation of scalar as single column, single row, record batch in Arrow IPC format
     *
     * @generated from field: bytes scalar = 1;
     */
    value: Uint8Array;
    case: "scalar";
  } | {
    /**
     *
     * Serialized Arrow record batch in Arrow IPC format
     *
     * @generated from field: bytes table = 2;
     */
    value: Uint8Array;
    case: "table";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<TaskValue>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "tasks.TaskValue";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "scalar", kind: "scalar", T: 12 /* ScalarType.BYTES */, oneof: "data" },
    { no: 2, name: "table", kind: "scalar", T: 12 /* ScalarType.BYTES */, oneof: "data" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TaskValue {
    return new TaskValue().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TaskValue {
    return new TaskValue().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TaskValue {
    return new TaskValue().fromJsonString(jsonString, options);
  }

  static equals(a: TaskValue | PlainMessage<TaskValue> | undefined, b: TaskValue | PlainMessage<TaskValue> | undefined): boolean {
    return proto3.util.equals(TaskValue, a, b);
  }
}

/**
 * @generated from message tasks.Variable
 */
export class Variable extends Message<Variable> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * @generated from field: tasks.VariableNamespace namespace = 2;
   */
  namespace = VariableNamespace.Signal;

  constructor(data?: PartialMessage<Variable>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "tasks.Variable";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "namespace", kind: "enum", T: proto3.getEnumType(VariableNamespace) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Variable {
    return new Variable().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Variable {
    return new Variable().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Variable {
    return new Variable().fromJsonString(jsonString, options);
  }

  static equals(a: Variable | PlainMessage<Variable> | undefined, b: Variable | PlainMessage<Variable> | undefined): boolean {
    return proto3.util.equals(Variable, a, b);
  }
}

/**
 * ## Scan URL Task
 *
 * @generated from message tasks.ParseFieldSpec
 */
export class ParseFieldSpec extends Message<ParseFieldSpec> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * @generated from field: string datatype = 2;
   */
  datatype = "";

  constructor(data?: PartialMessage<ParseFieldSpec>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "tasks.ParseFieldSpec";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "datatype", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ParseFieldSpec {
    return new ParseFieldSpec().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ParseFieldSpec {
    return new ParseFieldSpec().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ParseFieldSpec {
    return new ParseFieldSpec().fromJsonString(jsonString, options);
  }

  static equals(a: ParseFieldSpec | PlainMessage<ParseFieldSpec> | undefined, b: ParseFieldSpec | PlainMessage<ParseFieldSpec> | undefined): boolean {
    return proto3.util.equals(ParseFieldSpec, a, b);
  }
}

/**
 * @generated from message tasks.ParseFieldSpecs
 */
export class ParseFieldSpecs extends Message<ParseFieldSpecs> {
  /**
   * @generated from field: repeated tasks.ParseFieldSpec specs = 1;
   */
  specs: ParseFieldSpec[] = [];

  constructor(data?: PartialMessage<ParseFieldSpecs>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "tasks.ParseFieldSpecs";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "specs", kind: "message", T: ParseFieldSpec, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ParseFieldSpecs {
    return new ParseFieldSpecs().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ParseFieldSpecs {
    return new ParseFieldSpecs().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ParseFieldSpecs {
    return new ParseFieldSpecs().fromJsonString(jsonString, options);
  }

  static equals(a: ParseFieldSpecs | PlainMessage<ParseFieldSpecs> | undefined, b: ParseFieldSpecs | PlainMessage<ParseFieldSpecs> | undefined): boolean {
    return proto3.util.equals(ParseFieldSpecs, a, b);
  }
}

/**
 * @generated from message tasks.ScanUrlFormat
 */
export class ScanUrlFormat extends Message<ScanUrlFormat> {
  /**
   *
   * The data format type. The currently supported data formats are json (the default),
   * csv (comma-separated values), tsv (tab-separated values), dsv (delimited text files),
   * and topojson.
   *
   * @generated from field: optional string type = 1;
   */
  type?: string;

  /**
   *
   * JSON encoded string:
   * If set to auto, perform automatic type inference to determine the desired data types.
   * Alternatively, a parsing directive object can be provided for explicit data types.
   * Each property of the object corresponds to a field name, and the value to the desired data type
   * (one of "boolean", "date", "number" or "string"). For example, "parse": {"modified_on": "date"}
   * parses the modified_on field in each input record as a Date value. Specific date formats can
   * be provided (e.g., {"foo": "date:'%m%d%Y'"}), using the d3-time-format syntax. UTC date format
   * parsing is supported similarly (e.g., {"foo": "utc:'%m%d%Y'"}).
   *
   * @generated from oneof tasks.ScanUrlFormat.parse
   */
  parse: {
    /**
     * @generated from field: string string = 2;
     */
    value: string;
    case: "string";
  } | {
    /**
     * @generated from field: tasks.ParseFieldSpecs object = 3;
     */
    value: ParseFieldSpecs;
    case: "object";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * @generated from field: optional string property = 4;
   */
  property?: string;

  /**
   * @generated from field: repeated string header = 5;
   */
  header: string[] = [];

  /**
   * @generated from field: optional string delimiter = 6;
   */
  delimiter?: string;

  /**
   * @generated from field: optional string feature = 7;
   */
  feature?: string;

  constructor(data?: PartialMessage<ScanUrlFormat>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "tasks.ScanUrlFormat";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "string", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "parse" },
    { no: 3, name: "object", kind: "message", T: ParseFieldSpecs, oneof: "parse" },
    { no: 4, name: "property", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 5, name: "header", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 6, name: "delimiter", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 7, name: "feature", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ScanUrlFormat {
    return new ScanUrlFormat().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ScanUrlFormat {
    return new ScanUrlFormat().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ScanUrlFormat {
    return new ScanUrlFormat().fromJsonString(jsonString, options);
  }

  static equals(a: ScanUrlFormat | PlainMessage<ScanUrlFormat> | undefined, b: ScanUrlFormat | PlainMessage<ScanUrlFormat> | undefined): boolean {
    return proto3.util.equals(ScanUrlFormat, a, b);
  }
}

/**
 * @generated from message tasks.DataUrlTask
 */
export class DataUrlTask extends Message<DataUrlTask> {
  /**
   * @generated from oneof tasks.DataUrlTask.url
   */
  url: {
    /**
     * @generated from field: string string = 1;
     */
    value: string;
    case: "string";
  } | {
    /**
     * @generated from field: expression.Expression expr = 2;
     */
    value: Expression;
    case: "expr";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * @generated from field: int32 batch_size = 3;
   */
  batchSize = 0;

  /**
   * @generated from field: tasks.ScanUrlFormat format_type = 4;
   */
  formatType?: ScanUrlFormat;

  /**
   * @generated from field: transforms.TransformPipeline pipeline = 5;
   */
  pipeline?: TransformPipeline;

  constructor(data?: PartialMessage<DataUrlTask>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "tasks.DataUrlTask";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "string", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "url" },
    { no: 2, name: "expr", kind: "message", T: Expression, oneof: "url" },
    { no: 3, name: "batch_size", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 4, name: "format_type", kind: "message", T: ScanUrlFormat },
    { no: 5, name: "pipeline", kind: "message", T: TransformPipeline },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DataUrlTask {
    return new DataUrlTask().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DataUrlTask {
    return new DataUrlTask().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DataUrlTask {
    return new DataUrlTask().fromJsonString(jsonString, options);
  }

  static equals(a: DataUrlTask | PlainMessage<DataUrlTask> | undefined, b: DataUrlTask | PlainMessage<DataUrlTask> | undefined): boolean {
    return proto3.util.equals(DataUrlTask, a, b);
  }
}

/**
 * ## Inline values task
 *
 * @generated from message tasks.DataValuesTask
 */
export class DataValuesTask extends Message<DataValuesTask> {
  /**
   * @generated from field: bytes values = 1;
   */
  values = new Uint8Array(0);

  /**
   * @generated from field: tasks.ScanUrlFormat format_type = 2;
   */
  formatType?: ScanUrlFormat;

  /**
   * @generated from field: transforms.TransformPipeline pipeline = 3;
   */
  pipeline?: TransformPipeline;

  constructor(data?: PartialMessage<DataValuesTask>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "tasks.DataValuesTask";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "values", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "format_type", kind: "message", T: ScanUrlFormat },
    { no: 3, name: "pipeline", kind: "message", T: TransformPipeline },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DataValuesTask {
    return new DataValuesTask().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DataValuesTask {
    return new DataValuesTask().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DataValuesTask {
    return new DataValuesTask().fromJsonString(jsonString, options);
  }

  static equals(a: DataValuesTask | PlainMessage<DataValuesTask> | undefined, b: DataValuesTask | PlainMessage<DataValuesTask> | undefined): boolean {
    return proto3.util.equals(DataValuesTask, a, b);
  }
}

/**
 * ## Transform Task
 *
 * @generated from message tasks.DataSourceTask
 */
export class DataSourceTask extends Message<DataSourceTask> {
  /**
   * @generated from field: string source = 1;
   */
  source = "";

  /**
   * @generated from field: transforms.TransformPipeline pipeline = 2;
   */
  pipeline?: TransformPipeline;

  constructor(data?: PartialMessage<DataSourceTask>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "tasks.DataSourceTask";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "source", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "pipeline", kind: "message", T: TransformPipeline },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DataSourceTask {
    return new DataSourceTask().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DataSourceTask {
    return new DataSourceTask().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DataSourceTask {
    return new DataSourceTask().fromJsonString(jsonString, options);
  }

  static equals(a: DataSourceTask | PlainMessage<DataSourceTask> | undefined, b: DataSourceTask | PlainMessage<DataSourceTask> | undefined): boolean {
    return proto3.util.equals(DataSourceTask, a, b);
  }
}

/**
 * ## Signal Task
 *
 * @generated from message tasks.SignalTask
 */
export class SignalTask extends Message<SignalTask> {
  /**
   * @generated from field: expression.Expression expr = 2;
   */
  expr?: Expression;

  constructor(data?: PartialMessage<SignalTask>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "tasks.SignalTask";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "expr", kind: "message", T: Expression },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SignalTask {
    return new SignalTask().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SignalTask {
    return new SignalTask().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SignalTask {
    return new SignalTask().fromJsonString(jsonString, options);
  }

  static equals(a: SignalTask | PlainMessage<SignalTask> | undefined, b: SignalTask | PlainMessage<SignalTask> | undefined): boolean {
    return proto3.util.equals(SignalTask, a, b);
  }
}

/**
 * ## Timezone config
 *
 * @generated from message tasks.TzConfig
 */
export class TzConfig extends Message<TzConfig> {
  /**
   * @generated from field: string local_tz = 1;
   */
  localTz = "";

  /**
   * @generated from field: optional string default_input_tz = 2;
   */
  defaultInputTz?: string;

  constructor(data?: PartialMessage<TzConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "tasks.TzConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "local_tz", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "default_input_tz", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TzConfig {
    return new TzConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TzConfig {
    return new TzConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TzConfig {
    return new TzConfig().fromJsonString(jsonString, options);
  }

  static equals(a: TzConfig | PlainMessage<TzConfig> | undefined, b: TzConfig | PlainMessage<TzConfig> | undefined): boolean {
    return proto3.util.equals(TzConfig, a, b);
  }
}

/**
 * ## Top-level Task
 *
 * @generated from message tasks.Task
 */
export class Task extends Message<Task> {
  /**
   * @generated from field: tasks.Variable variable = 1;
   */
  variable?: Variable;

  /**
   * @generated from field: repeated uint32 scope = 2;
   */
  scope: number[] = [];

  /**
   * @generated from oneof tasks.Task.task_kind
   */
  taskKind: {
    /**
     * @generated from field: tasks.TaskValue value = 3;
     */
    value: TaskValue;
    case: "value";
  } | {
    /**
     * @generated from field: tasks.DataValuesTask data_values = 4;
     */
    value: DataValuesTask;
    case: "dataValues";
  } | {
    /**
     * @generated from field: tasks.DataUrlTask data_url = 5;
     */
    value: DataUrlTask;
    case: "dataUrl";
  } | {
    /**
     * @generated from field: tasks.DataSourceTask data_source = 6;
     */
    value: DataSourceTask;
    case: "dataSource";
  } | {
    /**
     * @generated from field: tasks.SignalTask signal = 7;
     */
    value: SignalTask;
    case: "signal";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * @generated from field: tasks.TzConfig tz_config = 8;
   */
  tzConfig?: TzConfig;

  constructor(data?: PartialMessage<Task>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "tasks.Task";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "variable", kind: "message", T: Variable },
    { no: 2, name: "scope", kind: "scalar", T: 13 /* ScalarType.UINT32 */, repeated: true },
    { no: 3, name: "value", kind: "message", T: TaskValue, oneof: "task_kind" },
    { no: 4, name: "data_values", kind: "message", T: DataValuesTask, oneof: "task_kind" },
    { no: 5, name: "data_url", kind: "message", T: DataUrlTask, oneof: "task_kind" },
    { no: 6, name: "data_source", kind: "message", T: DataSourceTask, oneof: "task_kind" },
    { no: 7, name: "signal", kind: "message", T: SignalTask, oneof: "task_kind" },
    { no: 8, name: "tz_config", kind: "message", T: TzConfig },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Task {
    return new Task().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Task {
    return new Task().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Task {
    return new Task().fromJsonString(jsonString, options);
  }

  static equals(a: Task | PlainMessage<Task> | undefined, b: Task | PlainMessage<Task> | undefined): boolean {
    return proto3.util.equals(Task, a, b);
  }
}

/**
 * ## Task Graph
 *
 * @generated from message tasks.IncomingEdge
 */
export class IncomingEdge extends Message<IncomingEdge> {
  /**
   * @generated from field: uint32 source = 1;
   */
  source = 0;

  /**
   * @generated from field: optional uint32 output = 2;
   */
  output?: number;

  constructor(data?: PartialMessage<IncomingEdge>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "tasks.IncomingEdge";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "source", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "output", kind: "scalar", T: 13 /* ScalarType.UINT32 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IncomingEdge {
    return new IncomingEdge().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IncomingEdge {
    return new IncomingEdge().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IncomingEdge {
    return new IncomingEdge().fromJsonString(jsonString, options);
  }

  static equals(a: IncomingEdge | PlainMessage<IncomingEdge> | undefined, b: IncomingEdge | PlainMessage<IncomingEdge> | undefined): boolean {
    return proto3.util.equals(IncomingEdge, a, b);
  }
}

/**
 * @generated from message tasks.OutgoingEdge
 */
export class OutgoingEdge extends Message<OutgoingEdge> {
  /**
   * @generated from field: uint32 target = 1;
   */
  target = 0;

  /**
   * @generated from field: bool propagate = 2;
   */
  propagate = false;

  constructor(data?: PartialMessage<OutgoingEdge>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "tasks.OutgoingEdge";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "target", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "propagate", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OutgoingEdge {
    return new OutgoingEdge().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OutgoingEdge {
    return new OutgoingEdge().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OutgoingEdge {
    return new OutgoingEdge().fromJsonString(jsonString, options);
  }

  static equals(a: OutgoingEdge | PlainMessage<OutgoingEdge> | undefined, b: OutgoingEdge | PlainMessage<OutgoingEdge> | undefined): boolean {
    return proto3.util.equals(OutgoingEdge, a, b);
  }
}

/**
 * @generated from message tasks.TaskNode
 */
export class TaskNode extends Message<TaskNode> {
  /**
   * @generated from field: tasks.Task task = 1;
   */
  task?: Task;

  /**
   * @generated from field: repeated tasks.IncomingEdge incoming = 2;
   */
  incoming: IncomingEdge[] = [];

  /**
   * @generated from field: repeated tasks.OutgoingEdge outgoing = 3;
   */
  outgoing: OutgoingEdge[] = [];

  /**
   * @generated from field: uint64 id_fingerprint = 4;
   */
  idFingerprint = protoInt64.zero;

  /**
   * @generated from field: uint64 state_fingerprint = 5;
   */
  stateFingerprint = protoInt64.zero;

  constructor(data?: PartialMessage<TaskNode>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "tasks.TaskNode";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "task", kind: "message", T: Task },
    { no: 2, name: "incoming", kind: "message", T: IncomingEdge, repeated: true },
    { no: 3, name: "outgoing", kind: "message", T: OutgoingEdge, repeated: true },
    { no: 4, name: "id_fingerprint", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 5, name: "state_fingerprint", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TaskNode {
    return new TaskNode().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TaskNode {
    return new TaskNode().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TaskNode {
    return new TaskNode().fromJsonString(jsonString, options);
  }

  static equals(a: TaskNode | PlainMessage<TaskNode> | undefined, b: TaskNode | PlainMessage<TaskNode> | undefined): boolean {
    return proto3.util.equals(TaskNode, a, b);
  }
}

/**
 * @generated from message tasks.TaskGraph
 */
export class TaskGraph extends Message<TaskGraph> {
  /**
   * @generated from field: repeated tasks.TaskNode nodes = 1;
   */
  nodes: TaskNode[] = [];

  constructor(data?: PartialMessage<TaskGraph>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "tasks.TaskGraph";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "nodes", kind: "message", T: TaskNode, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TaskGraph {
    return new TaskGraph().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TaskGraph {
    return new TaskGraph().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TaskGraph {
    return new TaskGraph().fromJsonString(jsonString, options);
  }

  static equals(a: TaskGraph | PlainMessage<TaskGraph> | undefined, b: TaskGraph | PlainMessage<TaskGraph> | undefined): boolean {
    return proto3.util.equals(TaskGraph, a, b);
  }
}

/**
 * @generated from message tasks.NodeValueIndex
 */
export class NodeValueIndex extends Message<NodeValueIndex> {
  /**
   * @generated from field: uint32 node_index = 1;
   */
  nodeIndex = 0;

  /**
   * @generated from field: optional uint32 output_index = 2;
   */
  outputIndex?: number;

  constructor(data?: PartialMessage<NodeValueIndex>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "tasks.NodeValueIndex";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "node_index", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "output_index", kind: "scalar", T: 13 /* ScalarType.UINT32 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NodeValueIndex {
    return new NodeValueIndex().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NodeValueIndex {
    return new NodeValueIndex().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NodeValueIndex {
    return new NodeValueIndex().fromJsonString(jsonString, options);
  }

  static equals(a: NodeValueIndex | PlainMessage<NodeValueIndex> | undefined, b: NodeValueIndex | PlainMessage<NodeValueIndex> | undefined): boolean {
    return proto3.util.equals(NodeValueIndex, a, b);
  }
}

/**
 * @generated from message tasks.TaskGraphValueRequest
 */
export class TaskGraphValueRequest extends Message<TaskGraphValueRequest> {
  /**
   * @generated from field: tasks.TaskGraph task_graph = 1;
   */
  taskGraph?: TaskGraph;

  /**
   * @generated from field: repeated tasks.NodeValueIndex indices = 2;
   */
  indices: NodeValueIndex[] = [];

  constructor(data?: PartialMessage<TaskGraphValueRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "tasks.TaskGraphValueRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "task_graph", kind: "message", T: TaskGraph },
    { no: 2, name: "indices", kind: "message", T: NodeValueIndex, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TaskGraphValueRequest {
    return new TaskGraphValueRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TaskGraphValueRequest {
    return new TaskGraphValueRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TaskGraphValueRequest {
    return new TaskGraphValueRequest().fromJsonString(jsonString, options);
  }

  static equals(a: TaskGraphValueRequest | PlainMessage<TaskGraphValueRequest> | undefined, b: TaskGraphValueRequest | PlainMessage<TaskGraphValueRequest> | undefined): boolean {
    return proto3.util.equals(TaskGraphValueRequest, a, b);
  }
}

/**
 * @generated from message tasks.ResponseTaskValue
 */
export class ResponseTaskValue extends Message<ResponseTaskValue> {
  /**
   * @generated from field: tasks.Variable variable = 1;
   */
  variable?: Variable;

  /**
   * @generated from field: repeated uint32 scope = 2;
   */
  scope: number[] = [];

  /**
   * @generated from field: tasks.TaskValue value = 3;
   */
  value?: TaskValue;

  constructor(data?: PartialMessage<ResponseTaskValue>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "tasks.ResponseTaskValue";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "variable", kind: "message", T: Variable },
    { no: 2, name: "scope", kind: "scalar", T: 13 /* ScalarType.UINT32 */, repeated: true },
    { no: 3, name: "value", kind: "message", T: TaskValue },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ResponseTaskValue {
    return new ResponseTaskValue().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ResponseTaskValue {
    return new ResponseTaskValue().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ResponseTaskValue {
    return new ResponseTaskValue().fromJsonString(jsonString, options);
  }

  static equals(a: ResponseTaskValue | PlainMessage<ResponseTaskValue> | undefined, b: ResponseTaskValue | PlainMessage<ResponseTaskValue> | undefined): boolean {
    return proto3.util.equals(ResponseTaskValue, a, b);
  }
}

/**
 * @generated from message tasks.TaskGraphValueResponse
 */
export class TaskGraphValueResponse extends Message<TaskGraphValueResponse> {
  /**
   * @generated from field: repeated tasks.ResponseTaskValue response_values = 1;
   */
  responseValues: ResponseTaskValue[] = [];

  constructor(data?: PartialMessage<TaskGraphValueResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "tasks.TaskGraphValueResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "response_values", kind: "message", T: ResponseTaskValue, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TaskGraphValueResponse {
    return new TaskGraphValueResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TaskGraphValueResponse {
    return new TaskGraphValueResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TaskGraphValueResponse {
    return new TaskGraphValueResponse().fromJsonString(jsonString, options);
  }

  static equals(a: TaskGraphValueResponse | PlainMessage<TaskGraphValueResponse> | undefined, b: TaskGraphValueResponse | PlainMessage<TaskGraphValueResponse> | undefined): boolean {
    return proto3.util.equals(TaskGraphValueResponse, a, b);
  }
}

